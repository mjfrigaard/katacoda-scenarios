---
title: "Build beautiful, customized graphs and charts in R with ggplot2"
author: "Martin Frigaard"
output: 
  github_document: 
    toc: yes
    toc_depth: 5
---

```{r setup, include=FALSE}
library(tidyverse)
library(knitr)
library(rmdformats)
# figs folder
if (!file.exists("figs")) {
  dir.create("figs")
}
knitr::opts_chunk$set(
  echo = TRUE,
  eval = TRUE,
  cache = FALSE,
  prompt = FALSE,
  tidy = FALSE,
  comment = "#>",
  message = FALSE,
  warning = FALSE,
  fig.path = "figs/"
)
knitr::opts_knit$set(
  width = 78
)
base::options(
  tibble.print_max = 25,
  tibble.width = 78,
  scipen = 100000000
)
```

# setup 

To see how to set up the Katacoda environment and layout, check out the `ggplot2-setup.Rmd` file.

# Outline 

Below are the 15 steps (plus `intro` and `finish`) files in the scenario. 

## intro

- [x] included in intro.md?

Welcome to 'Building beautiful, customized graphs and charts in R with ggplot2'! In this scenario we'll go over some basic graphing principles using the popular `ggplot2` package.

`ggplot2` is part of the `tidyverse`, which is a collection of opinionated packages from RStudio that ['*you're likely to use in everyday data analyses.*'](https://www.tidyverse.org/packages/)

### Exploring the data with ggplot2

In the previous scenario, we used the `tidyverse` and `fivethirtyeight` packages to wrangle data in R. 

<!-- insert link to previous scenario! -->

Now that we have some experience with data wrangling, we'll extend what we know into visualizing our data with the [`ggplot2`](https://ggplot2.tidyverse.org/) package. 

# step 1

- [x] included in step1.md?

## `ggplot2`: a quick overview

The `ggplot2` package is an implementation of the ["Grammar of Graphics"](https://amzn.to/2MRRCAB) by Leland Wilkinson. This text outlines a foundation for understanding the components of just about every graph or figure we've encountered (and some we haven't). `ggplot2` extends these concepts into a powerful grammar for developing data visualizations in R.

### Why have a 'grammar' of data visualization?

[Wilhelm von Humboldt](https://en.wikipedia.org/wiki/Wilhelm_von_Humboldt) has described a language as a system for "*making infinite use of finite means.*" Grammar is the set of rules we use to generate and display comprehensible thought (to humans or computers). Within the R language, `ggplot2` provides the grammar (or set of rules) we can learn to develop a rich vocabulary for data visualizations. Knowing how to use `ggplot2`'s grammar also gives us an excellent mental model for thinking about individual graphical elements. 

### The lingua franca for graphical elements

We'll extend the definition of 'grammar' above to include Steven Pinker's description of language in [The Sense of Style](https://www.amazon.com/Sense-Style-Thinking-Persons-Writing/dp/0143127799), "*[language is] our species’ solution to the problem of getting complicated thoughts from one head into another*." In this sense, the `ggplot2` package gives us an ability to communicate the *complexities* of our data in the same way that scientific jargon allows us to precisely and unambiguously define ideas. 

### Building graphs, bit-by-bit

Lastly, `ggplot2` has an expansive vocabulary, so by learning a finite list of `ggplot2` functions and their syntax will allow us to build a seemingly unlimited number of visualizations. 

## step 2

- [x] included in step2.md?

### Install and load the tidyverse

Launch an R console by clicking here -> `R`{{execute}} (Click on the *Run command* icon)

Load the `tidyverse` package by typing or copying and pasting the code below.

```r
install.packages("tidyverse")
library(tidyverse)
```

### Terms and definitions: `geoms` and `aes`thetics

A *geom* (or geometric object) is the 'thing' we see on a graph or plot (this includes dots or points, lines, bars, etc.).

*geoms* are combined with aesthetic mappings, which are properties of the 'thing' on the plot or graph (this includes things like color, size, position, and shape).

So every graph or plot has a geom, and that geom will also have some visual properties called aesthetics.

## Starting with quick plots

We will start using `ggplot2` with the `qplot()` function. `qplot()` is short for 'quick plot', and it takes the following arguments: 

```r
ggplot2::qplot(data = Data, # assume dataset 'Data'
               x = variable_x, # single column on the x
               y = variable_y, # single column on the y
               geom = "shape") # the 'thing' on the graph
```

## step 3

- [x] included in step3.md?

## the pipe `%>%`

A major reason for using the `tidyverse` is the pipe operator from the [`magrittr` package](https://magrittr.tidyverse.org/). 

The pipe (`%>%`) is what's referred to as syntactic sugar (yes, that's [really a term](https://en.wikipedia.org/wiki/Syntactic_sugar)) because it's,

"*syntax within a programming language that is designed to make things easier to read or to express*" 

Assume the same dataset `Data`, and two variables `variable_x` and `variable_y`. If we wanted to use the pipe with the `ggplot2::qplot()` function, it would look like the code below:

```{r qplot-syntax, eval=FALSE}
Data %>% 
  ggplot2::qplot(data = ., 
                 x = variable_x, 
                 y = variable_y,
                 geom = "shape")
```

### How the pipe works

Writing R code this way makes it easier to combine function calls, and it's easier for to read. For example, if we had to wrangle our data before creating a graph (which we almost always do), we wouldn't want to read the functions inside out: 

```r
# instead of this...
function_02(function_01(x), y) 

# we see this
x %>% function_01() %>% function_02(y) 
```

## step 4

- [x] included in step4.md?

## Using the pipe (cont.)

[`magrittr` package](https://magrittr.tidyverse.org/) has some additional tricks that are worth knowing. For example, in the code above, you may have noticed the `data = .` argument. 

```
Data %>% 
  ggplot2::qplot(data = ., 
                 x = variable_x, 
                 y = variable_y,
                 geom = "shape")
```

The period (`.`) here is a product of the pipe syntax. We use the `.` argument because of where the `data =` argument sits inside the `qplot()` function. See the `args()` by using `args(qplot)`{{execute}}


```
function(x, y, ..., data, 
        # all other optional arguments
        facets = NULL, 
        margins = FALSE, 
        geom = "auto", 
        xlim = c(NA, NA), 
        ylim = c(NA, NA), 
        log = "", 
        main = NULL, 
        xlab = NULL, 
        ylab = NULL, 
        asp = NA, 
        stat = NULL, 
        position = NULL) 
```

We can see the `data` argument comes *after* the `x`, `y`, and any other variable arguments `...`. That means we need to tell the pipe we want the `Data` to be in the named `data = ` argument, so we use `data = .`

So by using the pipe, we can rewrite this function,

```
function(y, named_argument = x)
```

to this:

```
x %>% function(y, named_argument = .)
```
 
By placing the `data = .` on the right-hand side of the pipe operator (`%>%`) in the `named_argument` position, we're telling R to read this statement as, "*the object to the left of the `%>%` belongs in the `data` argument.*" 

We can demonstrate this with the `diamonds` dataset in the `ggplot2` package. 

```{r diamonds-qplot}
diamonds <- ggplot2::diamonds
diamonds %>% 
  ggplot2::qplot(data = ., 
                 x = carat, 
                 y = price,
                 geom = "point")
```

See the figure below:

![](https://github.com/mjfrigaard/katacoda-scenarios/blob/master/figs/pipe-data-args.png?raw=true)


## step 5

- [x] included in step5.md?

## Lets get some data! 

We will be using `ggplot2` to explore data from the Economist's Medium post titled, ["Mistakes, we've drawn a few"](https://medium.economist.com/mistakes-weve-drawn-a-few-8cdd8a42d368). 

These data are available for download as part of the [#TidyTuesday](https://github.com/rfordatascience/tidytuesday) project on Github. 

```{r import-data}
# Brexit 
Brexit <- readr::read_csv("https://bit.ly/brexit-data")

# Corbyn 
Corbyn <- readr::read_csv("https://bit.ly/corbyn-data")

# Dogs 
Dogs <- readr::read_csv("https://bit.ly/dogs-data")

# EuBalance 
EuBalance <- readr::read_csv("https://bit.ly/eu-balance-data")

# Pensions 
Pensions <- readr::read_csv("https://bit.ly/pensions-data")

# Trade 
Trade <- readr::read_csv("https://bit.ly/trade-economist-data")

# WomenResearch 
WomenResearch <- readr::read_csv("https://bit.ly/women-research-data")
```

We can examine each dataset using the `dplyr::glimpse()`, `utils::head()`, or `utils::str()` arguments we learned about in the last scenario.
 
```{r check-Brexit}
Brexit %>% dplyr::glimpse()
Brexit %>% utils::head()
Brexit %>% utils::str()
```

More information on the datasets are below:

+ `Corbyn` is a dataset of average Facebook likes and political leader/group.

+ `Brexit` is a dataset of Brexit poll opinions (with dates).  

+ `Dogs` is a dataset of dog body weights (in kgs) and average neck size (in cm), along with the date the dog was registered with the UK's kennel club.

+ `EuBalance` is a dataset of countries, the country budget balance/current-account balance, the year, and the value in billions or euros. 

+ `Pensions` is a dataset of countries, percent of the country's population 65 years old or over, and the percent of government spending on pensions as percent of GDP.

+ `Trade` is a dataset of the United States trade deficit with China in goods (in US dollar), the manufacturing employment in the US, and the year.   

+ `WomenResearch` is a dataset of countries, field of scientific study, and women among researchers with papers published between 2011-15 as percent of the total by field of study.


## step 6

- [x] included in step6.md?

## Visualizing a single variable

Before we look at how variables relate to one another, we should get an idea for how each variable looks independently, or it's [distribution.](https://en.wikipedia.org/wiki/List_of_probability_distributions). 

How we visualize a variable's distribution depends on whether it's **numeric** or **categorical**.

**Numeric** variables can be *continuous*--which means they can be any value including `0`--and are typically thought of as raw measurements (i.e. human body weight, speed, time in seconds, etc.). 

*Categorical* numeric variables count discrete items or events, such as Facebook 'like's or number of page views. Categorical numeric variables are different from continuous variables because the have a fixed set of possible values (i.e. you can't have 1/2 a Facebook 'like'). 

A special case of categorical variable is a *binary* variable, which only has two possible values (`0` or `1`, `alive` or `dead`, `yes` or `no`, etc.)

### Creating a single variable plot

We will view the distribution of the `avg_facebook_likes` from the `Corbyn` dataset using `ggplot2::qplot()`. 

```{r step-6-plot}
# the data 
Corbyn %>% 
  # the variable 
  ggplot2::qplot(x = avg_facebook_likes, 
                 # the dot
                 data = .) 
```

*What is this graph telling us?* 

Well, we can print the entire Corbyn dataset to the console to view it (it's not very big). 

![](https://github.com/mjfrigaard/katacoda-scenarios/blob/master/figs/06-corbyn-tibble.png?raw=true)

We can see the tibble printed to the screen has the `avg_facebook_likes` sorted descending, with the highest number on top (`5210`) and the lowest number on the bottom (`56`). 

When we give the `qplot()` function a single variable, it assumes we want a [histogram](https://ggplot2.tidyverse.org/reference/geom_histogram.html). 

The histogram is displaying the `avg_facebook_likes` variable by splitting up the x axis into `bins`, then plotting the count for each number of observations in each bin on the `y` axis.

![](https://github.com/mjfrigaard/katacoda-scenarios/blob/master/figs/06-corbyn-histogram.png?raw=true)


## step 7 

- [x] included in step7.md

## Visualizing a single variable (cont.)

Histograms are a great way to visualize the distribution of a single variable, but there are other `geom`s too. For example, the box-plot gives us a graph and quite a few summary statistics for any given numerical variable.

Below is a box-plot of the `pop_65_percent` from the `Pensions` dataset. 

```{r step-7-plot}
# the data 
Pensions %>% 
  # the variable 
  ggplot2::qplot(x = pop_65_percent, 
                 # the dot
                 data = .,
                 geom = "boxplot") 
```

The box-plot gives us an idea of `pop_65_percent`'s distribution by using the white box to show where the median (middle value), 1st and 3rd quartiles, higher/lower values, and outliers (see image below)

![](https://github.com/mjfrigaard/katacoda-scenarios/blob/master/figs/07-boxplot.png?raw=true)

For more on the statistics displayed in the box-plot, read up on the [`geom_boxplot()` documentation](https://ggplot2.tidyverse.org/reference/geom_boxplot.html). 

Other options for individual variables include the [`geom = "density"`](https://ggplot2.tidyverse.org/reference/geom_density.html) and [`geom = "violin"`](https://ggplot2.tidyverse.org/reference/geom_violin.html).

## step 8

- [x] included in step8.md

## Visualizing the relationship between two variables

What if we want to graph the relationship between two variables? In this step, we'll graph two variables from the `Brexit` dataset. Use the terminal to view this dataset with `dplyr::glimpse()` or `utils::str()`:

```{r glimpse-brexit}
dplyr::glimpse(Brexit)
utils::str(object = Brexit)
```

When we view the contents of `Brexit`, we can see the `date` column is a character variable (`<chr>`), and the other two variables--`percent_responding_right` and `percent_responding_wrong`--are numeric (`<dbl>`). 

### Changing character variables to dates 

If we want to plot the relationship between `date` and the `percent_responding_right`, we'll first need to change the format of `date` from character to `Date`, which we can do using the [`lubridate` package](https://lubridate.tidyverse.org/) (also from the `tidyverse`). 

Copy the code below and complete the `lubridate::mdy()` function to format the `date` variable as a `Date`. 

```{r change-date-to-date}
# first reformat the date variable as a date
# Brexit <- Brexit %>% mutate(date = lubridate::mdy(____))
Brexit <- Brexit %>% mutate(date = lubridate::mdy(date))
```

Use the `base::is.double()`, `base::class()`, or `base::typeof()` function to figure out if you've formatted the new `date` variable correctly.

```{r check-date-as-date}
base::is.double(Brexit$date)
base::class(Brexit$date)
base::typeof(Brexit$date)
```

After we're sure the `date` variable has been formatted correctly, we want to 'pipe' the formatted data to the `ggplot2::qplot()` function with the new `date` variable on the `x` and the `percent_responding_right` variable on the `y`.

```{r lubridate}
Brexit %>% qplot(x = date, y = percent_responding_right, data = .)
```

The `ggplot2::qplot()` function is smart enough to automatically choose a `geom` depending on what type of variable we assign to the `x` and `y` axes. In this case, the `percent_responding_right` variable is a `<dbl>` (numeric), and we've reformatted the `date` variable into a double before we passed it to the `y` axis.

The `ggplot2::qplot()` function knows to plot the dates on the `y` axes (notice it displays only the `year`) and represent the data with `geom = "points"`.

## step 9 

- [x] included in the step9.md?

## Wrangling and visualizing 

Sometimes we might want to pass the data directly from a wrangling step to a data visualization without assigning changes to the data frame. We will demonstrate how this works using the same `Brexit` dataset. 

If you read the [Medium article](https://medium.economist.com/mistakes-weve-drawn-a-few-8cdd8a42d368), you'll find The Economist first plotted these data as a line graph, with two lines (see 'Original' image below). The 'Better' way to improve the graph would be to include points and smooth the line in the graph (see below):

![](https://miro.medium.com/max/1400/1*9GzHVtm4y_LeVmFCjqV3Ww.png)

In order to re-create these graphs, we'll need to restructure the `Brexit` data with the `tidyr::pivot_longer()` function we learned about in the last [scenario]().

Complete the code below by filling in the `cols = ` argument as `date`, the `names_to = ` as `"poll"`, and the `values_to = ` as `"percent"`.

```
Brexit %>% pivot_longer(cols = , names_to =, values_to =)
```

We should end up with a dataset that has three variables: `date`, `poll`, and `percent`. The data below display the top six rows you should see when you've used `tidyr::pivot()` correctly. 

```
# A tibble: 170 x 3
   date       poll                     percent
   <date>     <chr>                      <dbl>
 1 2016-02-08 percent_responding_right      46
 2 2016-02-08 percent_responding_wrong      42
 3 2016-09-08 percent_responding_right      45
 4 2016-09-08 percent_responding_wrong      44
 5 NA         percent_responding_right      46
 6 NA         percent_responding_wrong      43
```

After we're sure the data are structured correctly, we won't assign it to the `Brexit` data frame. Instead, we'll pass it straight through to the `ggplot2::qplot()` function. The `date` variable will go on the `x`, and the `percent` variable will go on the `y`. Click on the Run icon below to see the graph.

First, we will create the 'Original' graph by using `geom = "line'`, but we want a separate line for each `poll`. We can create this by adding the `color = poll` aesthetic. 

```{r original-graph}
Brexit %>% 
  pivot_longer(cols = -date, 
               names_to = "poll", 
               values_to = "percent") %>% 
  ggplot2::qplot(x = date, 
                 y = percent, 
                 data = .,
                 geom = "line",
                 color = poll)
```

As we can see from the graph above, being able to use the `color` aesthetic extends the `qplot()`s capabilities by making it clear there are two categories for `polls` represented in the graph.

In the next step, we'll re-create the `Brexit` dataset.

## step 10

- [ ] included in step10.md

## Building plots layer-by-layer with `ggplot()`

Now that we've learned how to plot using geoms and aesthetics, we can begin adding layers to the graph. In the previous step, we re-created the 'Original' plot using `geom = "line"`.

As we start to build more complex, customized plots, we will want to move away from using the `ggplot2::qplot()` function and start using `ggplot2::ggplot()` function.

The `ggplot2::ggplot()` function initializes a graph, then we can 'map' variables to the axes, aesthetics, or groupings. We'll start by assigning the restructuring changes to the `Brexit` dataset. 

```{r change-Brexit}
Brexit <- Brexit %>% pivot_longer(-date, 
                                  names_to = "poll", 
                                  values_to = "percent")
```

The `ggplot()` follows a pretty standard template, and it's similar to the `qplot()` function. See below: 

```
<DATA> %>% 
  ggplot(mapping = aes(x = <MAPPINGS>, y = <MAPPINGS>))
```

We begin with a dataset, pass it over to to the `ggplot()` function, then map the `x` and `y` variables. Run the code below to assign the variable mappings to object `p`.

```{r mappings}
p <- Brexit %>% ggplot(mapping = aes(x = date, y = percent, color = poll))
p
```

There aren't any points on the graph stored in object `p` because we haven't added any geoms or aesthetics. We'll add the smoothed line in the step below with `ggplot2::geom_smooth()` like the template below.

```
<DATA> %>% 
  ggplot(mapping = aes(x = <MAPPINGS>, y = <MAPPINGS>)) + 
    <GEOM_FUNCTION>()
```

**Note**: the `+` operator is used with `ggplot2` functions, not the pipe `%>%` operator. 

```{r geom_smooth}
p + ggplot2::geom_smooth()
```

The default `ggplot2::geom_smooth()` function includes the gray confidence interval around the smoothed line. We can remove this with `se = FALSE`. We'll also add the `show.legend = FALSE` argument to remove the `poll` categories from the left-hand side of the graph.

Copy the code below and complete the `show.legend` argument and assign the graph to the `p_smooth` object.

```{r standard-error-and-legend}
p_smooth <- p + geom_smooth(se = FALSE, show.legend = FALSE)
p_smooth
```

In the next step, we'll add the points to the graph.

## step 11

## Adding aesthetics and layers 

In the last step we added a `geom_smooth()` to the `p` object and removed the standard errors (`se = FALSE`) and legend (`show.legend = FALSE`). We stored these changes in the `p_smooth` object. 

We're going to continue building our plot by adding the `ggplot2::geom_point()` function, but we'll also include the `show.legend = FALSE` argument again to remove the legend for the two `poll` categories.

```{r geom_point}
p_smooth +
  geom_point(show.legend = FALSE)
```

This looks more like the graph in the medium article, but still need to make a few minor adjustments. The points in the 


![](https://miro.medium.com/max/1400/1*9GzHVtm4y_LeVmFCjqV3Ww.png)


```
<DATA> %>% 
  ggplot(mapping = aes(x = <MAPPINGS>, y = <MAPPINGS>)) + 
    <GEOM_FUNCTION>(mapping = aes(<MAPPINGS>))
```

We can continue adding `geom`s and 

```{r}
  
  ggthemes::theme_economist_white(gray_bg = FALSE)
```






The variables outlined above are `num_shows`, `num_lead`, `num_support`, and they give us the `score_div_y` (or *"Score" divided by "Years Since"*). The `score_div_y` and `years_since` then give us the total `score`. These data are presented in the article as a table, but I'll explore the `score` variable using two geoms from `ggplot2`. 

### The bar plot

Using the geoms in `ggplot2::qplot()` means supplying the `geom =` argument with a type of graph. 

A bar-plot might help us understand the distribution of `score` in the `MadMen` data. I can build this graph using the template above, substituting the `MadMen` for `Data`, `score` in the `x` variable position, and `"bar"` for `"shape"`.

```{r bar-plot}
MadMen %>% ggplot2::qplot(data = ., 
                        x = score, 
                        geom = "bar")
```

#### What is this graph telling us? 

The `geom = "bar"` displays the `score` values in the height of each bar (i.e. their `count`, as indicated by the `y` axis). These bars aren't equal heights, and the highest bar is at `0`. Fewer tall bars are on the right side of the graph (high `score`s), only four bars have a `count` higher than `10` (all are under `5`). 

The article indicated, "*The median actor in our set had a score of 2*", but it's not clear where the median value is in the bar-plot. To view how this statistic fits into the distribution of `score`, I will use the `geom = "boxplot"`.

### A box-plot

Change the code above to use a `geom = "boxplot"`, but map `score` to the `y` axis and give the `x` axis a blank character string (`" "`). 

```{r box-plot}
MadMen %>% ggplot2::qplot(data = ., 
                        x = " ", 
                        y = score,
                        geom = "boxplot") 
```


#### What is this graph telling us? 

Box-plots (or box and whisker plots) display five statistical concepts in a single graph. These were initially introduced by John Tukey in his 1977 book, ["Exploratory Data Analysis."](https://amzn.to/2t8lUWI)

<!-- The image below is a taken from page 41,  -->
<!-- ```{r IMAGE-og-box-whisker, echo=FALSE} -->
<!-- # fs::dir_ls("figs") -->
<!-- knitr::include_graphics(path = "figs/og-box-whisker.png") -->
<!-- ``` -->

Box-plots display the five number summary, which includes the smallest, largest, median, and upper and lower quartiles (quartiles divide the numbers into a percentage, and the 25th and 75th are included on the graph). Box-plots also display 'outliers', or extreme values as dots or points. 

In order to get an idea of what I should be seeing on the graph, I will use the `base::summary()` function to list the `Min`, `1st Qu.`, `Median`, `Mean`, `3rd Qu.`, and `Max.` This is a five number summary plus the mean (or average).

```{r summary-score}
base::summary(MadMen$score)
```

The `Median` is the horizontal line within the box, and if I look over to the `y` axis, I can see this corresponds to a score of 2 (just like the article stated).

```{r IMAGE-box-plot-median, echo=FALSE}
# fs::dir_ls("figs")
knitr::include_graphics(path = "figs/box-plot-median.png")
```

Can you guess which bars in the bar-plot correspond to the points on the box-plot?

## Output the new tables as csv files

Use `write_csv(as.data.frame(x = Data, file = "path/to/file.csv"))` and voilá, you have a csv.

```{r tidy-export, eval=FALSE}
readr::write_csv(as.data.frame(MadMen), path = "data/MadMen.csv")
```

<!---
## A recap of what we learned

We used the pipe operator to string together various `tidyr` and `dplyr` functions for structuring our data (in tibbles). Remember that:

- `dplyr::arrange()` sorts the data in each column  

- `tidyr::separate()` divides the contents of a column apart into new *columns* 
- `tidyr::separate_rows()` split the contents of a column into new *rows* 
- `tidyr::unite()` sticks the contents from one column onto the contents of another column  

- `tidyr::gather()` collects and indexes data across columns and puts them into into rows 
- `tidyr::spread()` distributes indexed data from rows into columns  

- using `geom`s in `ggplot2::qplot()` 

- `base::summary()` to get the five number (and mean) 

In the next tutorial we will expand our `ggplot2` abilities. 

### End
--->
