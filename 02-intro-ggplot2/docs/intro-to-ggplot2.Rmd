---
title: "Build beautiful, customized graphs and charts in R with ggplot2"
author: "Martin Frigaard"
output: 
  html_document: 
    toc: yes
    toc_float: yes
    highlight: tango
    theme: cosmo

always_allow_html: true
---

```{r setup, include=FALSE}
library(tint)
library(tidyverse)
library(knitr)
library(rmdformats)
# folders
knitr::opts_chunk$set(
  echo = TRUE,
  eval = TRUE,
  cache = FALSE,
  prompt = FALSE,
  tidy = FALSE,
  comment = "#>",
  message = FALSE,
  warning = FALSE,
  fig.path = "figs/"
)
knitr::opts_knit$set(
  width = 78
)
base::options(
  tibble.print_max = 25,
  tibble.width = 78,
  scipen = 100000000
)
```

# Setup 

This [scenario](https://www.katacoda.com/orm-mfrigaard) is setup using the following configuration:

```json
  "environment": {
    "uilayout": "vscode-terminal-split",
    "showide": true
  },
  "backend": {
    "imageid": "rlang:3.4"
  }
```

# Outline 

Below are the 15 steps (plus `intro` and `finish`) files in the scenario. 

## Objectives

The objectives for this scenario are: 

- [ ] Explain why there is as Grammar of Graphics is and what problem it solves

- [ ] Define the terms `geom` and `aesthetic`

- [ ] Compare and contrast function calls with and without the pipe operator

- [ ] Create a visualization using `ggplot2`'s quickplot function (`qplot()`)  

- [ ] Build a graph one layer at a time using the `ggplot` template 

## The learners 

The learners I'm expecting to be participating in this course are: 

- **Alice** will take this class on her own time for professional development. 

- **Sam** will this course in a two-day weekend because he needs to complete a project.

- **Betty** is using these scenarios to supplement a semester-long undergraduate course on R.

- **Gene** has been told to take this course for his job because his team is using R.


## intro

- [x] included in intro.md?

### Introduction to `ggplot2`

Welcome to 'Building beautiful, customized graphs and charts in R with `ggplot2`'! In this scenario we'll go over some basic graphing principles using the popular `ggplot2` package.

`ggplot2` is part of the `tidyverse`, which is a collection of opinionated packages from RStudio that ['*you're likely to use in everyday data analyses.*'](https://www.tidyverse.org/packages/)

### Exploring the data with `ggplot2`

In the [previous scenario](https://katacoda.com/orm-mfrigaard/scenarios/01-format-shape-data), we used the `tidyverse` and `fivethirtyeight` packages to wrangle data in R. 

Now that we have some experience with data wrangling, we'll extend what we know into visualizing our data with the [`ggplot2`](https://ggplot2.tidyverse.org/) package. 

## step 1

- [x] included in step1.md?

### `ggplot2`: a quick overview

The `ggplot2` package is an implementation of the ["Grammar of Graphics"](https://amzn.to/2MRRCAB) by Leland Wilkinson. This text outlines a foundation for understanding the components of just about every graph or figure we've encountered (and some we haven't). `ggplot2` extends these concepts into a powerful grammar for developing data visualizations in R.

#### Why have a 'grammar' of data visualization?

[Wilhelm von Humboldt](https://en.wikipedia.org/wiki/Wilhelm_von_Humboldt) has described a language as a system for "*making infinite use of finite means.*" Grammar is the set of rules we use to generate and display comprehensible thought (to humans or computers). Within the R language, `ggplot2` provides the grammar (or set of rules) we can learn to develop a rich vocabulary for data visualizations. Knowing how to use `ggplot2`'s grammar also gives us an excellent mental model for thinking about individual graphical elements. 

#### The lingua franca for graphical elements

We'll extend the definition of 'grammar' above to include Steven Pinker's description of language in [The Sense of Style](https://www.amazon.com/Sense-Style-Thinking-Persons-Writing/dp/0143127799), "*[language is] our speciesâ€™ solution to the problem of getting complicated thoughts from one head into another*." In this sense, the `ggplot2` package gives us an ability to communicate the *complexities* of our data in the same way that scientific jargon allows us to precisely and unambiguously define ideas. 

#### Building graphs, bit-by-bit

Lastly, `ggplot2` has an expansive vocabulary, so by learning a finite list of `ggplot2` functions and their syntax will allow us to build a seemingly unlimited number of visualizations. 

## step 2

- [x] included in step2.md?

### Install and load the tidyverse

Launch an R console by clicking here -> `R`{{execute}} (Click on the *Run command* icon)

Load the `tidyverse` package by typing or copying and pasting the code below.

```{r package, eval=FALSE}
install.packages("tidyverse")
library(tidyverse)
```

### Terms and definitions: `geoms` and `aes`thetics

A *geom* (or geometric object) is the 'thing' we see on a graph or plot (this includes dots or points, lines, bars, etc.).

*geoms* are combined with aesthetic mappings, which are properties of the 'thing' on the plot or graph (this includes things like color, size, position, and shape).

So every graph or plot has a geom, and that geom will also have some visual properties called aesthetics.

### Starting with quick plots

We will start using `ggplot2` with the `qplot()` function. `qplot()` is short for 'quick plot', and it takes the following arguments: 

```r
ggplot2::qplot(data = Data, # assume dataset 'Data'
               x = variable_x, # single column on the x
               y = variable_y, # single column on the y
               geom = "shape") # the 'thing' on the graph
```

## step 3

- [x] included in step3.md?

### the pipe `%>%`

A major reason for using the `tidyverse` is the pipe operator from the [`magrittr` package](https://magrittr.tidyverse.org/). 

The pipe (`%>%`) is what's referred to as syntactic sugar (yes, that's [really a term](https://en.wikipedia.org/wiki/Syntactic_sugar)) because it's,

"*syntax within a programming language that is designed to make things easier to read or to express*" 

Assume the same dataset `Data`, and two variables `variable_x` and `variable_y`. If we wanted to use the pipe with the `ggplot2::qplot()` function, it would look like the code below:

```
Data %>% ggplot2::qplot(data = ., x = variable_x, y = variable_y, geom = "shape")
```

#### How the pipe works

Writing R code this way makes it easier to combine function calls, and it's easier for to read. For example, if we had to wrangle our data before creating a graph (which we almost always do), we wouldn't want to read the functions inside out: 

```r
# instead of this...
function_02(function_01(x), y) 

# we see this
x %>% function_01() %>% function_02(y) 
```

## step 4

- [x] included in step4.md?

### Using the pipe (cont.)

[`magrittr` package](https://magrittr.tidyverse.org/) has some additional tricks that are worth knowing. For example, in the code above, you may have noticed the `data = .` argument. 

```
Data %>% 
  ggplot2::qplot(data = ., 
                 x = variable_x, 
                 y = variable_y,
                 geom = "shape")
```

The period (`.`) here is a product of the pipe syntax. We use the `.` argument because of where the `data =` argument sits inside the `qplot()` function. See the `args()` by using `args(qplot)`{{execute}}


```
function(x, y, ..., data, 
        # all other optional arguments
        facets = NULL, 
        margins = FALSE, 
        geom = "auto", 
        xlim = c(NA, NA), 
        ylim = c(NA, NA), 
        log = "", 
        main = NULL, 
        xlab = NULL, 
        ylab = NULL, 
        asp = NA, 
        stat = NULL, 
        position = NULL) 
```

We can see the `data` argument comes *after* the `x`, `y`, and any other variable arguments `...`. That means we need to tell the pipe we want the `Data` to be in the named `data = ` argument, so we use `data = .`

So by using the pipe, we can rewrite this function,

```
function(y, named_argument = x)
```

to this:

```
x %>% function(y, named_argument = .)
```
 
By placing the `data = .` on the right-hand side of the pipe operator (`%>%`) in the `named_argument` position, we're telling R to read this statement as, "*the object to the left of the `%>%` belongs in the `data` argument.*" 

See the figure below:

<!-- ![](https://github.com/mjfrigaard/katacoda-scenarios/blob/master/figs/pipe-data-args.png?raw=true) -->

```{r pipe-data-args, echo=FALSE}
knitr::include_graphics(path =
"https://raw.githubusercontent.com/mjfrigaard/katacoda-scenarios/master/figs/pipe-data-args.png")
# "https://github.com/mjfrigaard/katacoda-scenarios/blob/master/figs/pipe-data-args.png?raw=true"
```

We can demonstrate this in the code section below: 

- First we create a `diamonds` dataset from the `ggplot2` package, 
- Then we 'pipe' the data to `qplot()`  
- Then we include the `ggsave()` function (which allows us to save the graph image as a .png file)  

```{r gg-step4-png}
# data 
diamonds <- ggplot2::diamonds
# graph
diamonds %>% 
  ggplot2::qplot(data = ., 
                 x = carat, y = price, 
                 geom = "point")
# save
# ggsave(filename = "gg-step4.png", device = "png", width = 7, height = 5, 
       # units = "in")
```



## step 5

- [x] included in step5.md?

### Viewing our images

Now we have an image file in our `ROOT` folder above. We can click on `gg-step4.png` and it will open in an adjacent window.

<!-- ![](https://github.com/mjfrigaard/katacoda-scenarios/blob/master/figs/vscode-png.png?raw=true) -->

```{r vscode-png, echo=FALSE}
knitr::include_graphics(path = "https://raw.githubusercontent.com/mjfrigaard/katacoda-scenarios/master/figs/vscode-png.png")
```

And just like that, `ggplot2` allows us to create high-quality graphs with only a few lines of code!

### Lets get some data! 

We will be using `ggplot2` to explore data from the Economist's Medium post titled, ["Mistakes, we've drawn a few"](https://medium.economist.com/mistakes-weve-drawn-a-few-8cdd8a42d368). These data are available for download as part of the [#TidyTuesday](https://github.com/rfordatascience/tidytuesday) project on Github. Click on the code section below to import the data. 

```{r import-data}
# Balance 
Balance <- readr::read_csv("https://bit.ly/eu-balance-data")
# Brexit 
Brexit <- readr::read_csv("https://bit.ly/brexit-data")
# Corbyn 
Corbyn <- readr::read_csv("https://bit.ly/corbyn-data")
# Pensions 
Pensions <- readr::read_csv("https://bit.ly/pensions-data")
```

The code below displays each dataset using three different functions: `dplyr::glimpse()`, `utils::head()`, and `utils::str()` (*we learned about these functions in the last scenario*)
 
```{r check-data}
Brexit %>% dplyr::glimpse()
Corbyn %>% utils::head()
Pensions %>% utils::str()
```


We've provided some additional information on each datasets below:

+ `Corbyn` is a dataset of average Facebook likes and political leaders/groups.

+ `Brexit` is a dataset of Brexit poll opinions (with dates).  

+ `Balance` is a dataset with countries, the country budget balance/current-account balance, the year, and the value in billions of euros. 

+ `Pensions` is a dataset of countries, percent of the country's population 65 years old or over, and the percent of government spending on pensions as a percent of GDP.


## step 6

- [x] included in step6.md?

### Variable types

Before we look at how variables relate to each other, we should get an idea of how each variable looks independently, or it's [distribution.](https://en.wikipedia.org/wiki/List_of_probability_distributions). 

How we visualize a variable's distribution depends on whether it's **continuous**, **categorical**, or **binary**.

**Continuous** variables mean they can be any value including `0`--and are typically thought of as raw measurements (i.e., human body weight, speed, time in seconds, etc.). Continuous variables also can have decimal values that make sense.

**Categorical** variables count discrete items or events, such as Facebook 'like's or the number of page views. Categorical variables are different from continuous variables because they have a fixed set of possible values (i.e. you can't have 1/2 a Facebook 'like'). 

A particular case of a categorical variable is a **binary** variable, which only has two possible values (`0` or `1`, `alive` or `dead`, `yes` or `no`, etc.).

#### Visualize a single variable: histograms

We will view the distribution of the `avg_facebook_likes` from the `Corbyn` dataset using `ggplot2::qplot()`. Click below:

```{r step-6-plot-01}
Corbyn %>% 
    ggplot2::qplot(x = avg_facebook_likes, data = .) 
# save
# ggsave(filename = "gg-step6-hist.png", device = "png", 
        # width = 7, height = 5, units = "in")
```

*What is this graph telling us?* 

Well, we can print the entire `Corbyn` dataset to the console to view it (it's not very big). 

<!-- ![](https://github.com/mjfrigaard/katacoda-scenarios/blob/master/figs/06-corbyn-tibble.png?raw=true) -->

```{r 06-corbyn-tibble, echo=FALSE}
# fs::dir_ls("../figs")
# knitr::include_graphics(path = "../figs/06-corbyn-tibble.png")
knitr::include_graphics(path = "https://raw.githubusercontent.com/mjfrigaard/katacoda-scenarios/master/figs/06-corbyn-tibble.png")
```

We can see the data printed to the screen has the `avg_facebook_likes` variable sorted descending, with the highest number on top (`5210`), and the lowest number on the bottom (`56`). 

When we give the `qplot()` function a single numerical variable, it assumes we want a [histogram](https://ggplot2.tidyverse.org/reference/geom_histogram.html). 

The histogram displays the `avg_facebook_likes` variable by splitting up the `x` axis into `bins`, then plotting the count for each number of observations in each bin on the `y` axis.

<!-- ![](https://github.com/mjfrigaard/katacoda-scenarios/blob/master/figs/06-corbyn-histogram.png?raw=true) -->

```{r 06-corbyn-histogram, echo=FALSE}
# fs::dir_ls("../figs")
# knitr::include_graphics(path = "../figs/06-corbyn-histogram.png")
knitr::include_graphics(path = "https://raw.githubusercontent.com/mjfrigaard/katacoda-scenarios/master/figs/06-corbyn-histogram.png")
```

#### Visualize a single variable: box-plots

Histograms are a great way to visualize the distribution of a single variable, but there are other `geom`s, too. For example, a box-plot gives us a graph with quite a few summary statistics.

Click the code section below to create a box-plot of the `pop_65_percent` from the `Pensions` dataset.

```{r step-6-plot-02}
# the data 
Pensions %>% 
  # the variable 
  ggplot2::qplot(x = pop_65_percent, 
                 y = " ",
                 # the dot
                 data = .,
                 geom = "boxplot")
# ggsave(filename = "gg-step6-box.png", device = "png", 
        # width = 7, height = 5, units = "in")
```

Our new graph (`gg-step6-box.png`) should be in the `ROOT` folder above. Click on it to view.

The box-plot gives us an idea of `pop_65_percent`'s distribution using the white box to show where the median (middle value), 1st and 3rd quartiles, higher/lower values, and outliers (see image below). 

<!-- ![](https://github.com/mjfrigaard/katacoda-scenarios/blob/master/figs/07-boxplot.png?raw=true) -->

```{r 07-boxplot, echo=FALSE}
# fs::dir_ls("../figs")
# knitr::include_graphics(path = "../figs/07-boxplot.png")
knitr::include_graphics(path = "https://raw.githubusercontent.com/mjfrigaard/katacoda-scenarios/master/figs/07-boxplot.png")
```


## step 7 

- [x] included in step7.md

### Visualizing a numerical and categorical variable

Box-plots are also great for visualizing continuous variables across the levels of a categorical variable. For example, we have the `Balance` dataset with `value`s of European Union countries' budget surplus. We can add the categorical variable to the `y` axis to view one box-plot per `country` level.

```{r box-plot2}
# the data
Balance %>% 
  ggplot2::qplot(x = value, y = country, 
                 data = ., geom = "boxplot") 
# ggsave(filename = "gg-step7-box.png", device = "png", 
        # width = 7, height = 5, units = "in")
```


Click on the `gg-step7-box.png` file in `ROOT` folder above. For more on the statistics displayed in the box-plot, read up on the [`geom_boxplot()` documentation](https://ggplot2.tidyverse.org/reference/geom_boxplot.html).  

Other options for individual variables include the [`geom = "density"`](https://ggplot2.tidyverse.org/reference/geom_density.html) and [`geom = "violin"`](https://ggplot2.tidyverse.org/reference/geom_violin.html).

### Visualizing two continuous variables

What if we want to graph the relationship between two variables? In this step, we'll graph two variables from the `Brexit` dataset. Use the terminal to view this dataset with `dplyr::glimpse()` or `utils::str()`.

When we view the contents of `Brexit`, we can see the `date` column is a character variable (`<chr>`), and the other two variables--`percent_responding_right` and `percent_responding_wrong`--are numeric (`<dbl>`). 

#### Creating date variables

If we want to plot the relationship between `date` and the `percent_responding_right`, we'll first need to change the format of `date` from character to `Date`, which we can do using the [`lubridate` package](https://lubridate.tidyverse.org/) (also from the `tidyverse`). 

Copy the code below and complete the `lubridate::mdy()` function to format the `date` variable as a `Date`. 

```{r change-date-to-date}
# first reformat the date variable as a date
# Brexit <- Brexit %>% mutate(date = lubridate::dmy(____))
Brexit <- Brexit %>% mutate(date = lubridate::dmy(date))
```

Read more about `dmy()` [here.](https://lubridate.tidyverse.org/reference/ymd.html)

Use the `base::is.double()`, `base::class()`, or `base::typeof()` function to figure out if you've formatted the new `date` variable correctly.

```{r check-date-as-date}
base::is.double(Brexit$date)
base::class(Brexit$date)
base::typeof(Brexit$date)
```

After we're sure we've formatted the `date` variable correctly, we want to 'pipe' the formatted data to the `ggplot2::qplot()` function with the new `date` variable on the `x` and the `percent_responding_right` variable on the `y'.

```{r lubridate}
Brexit %>% 
  qplot(x = date, 
        y = percent_responding_right, data = .)
# ggsave(filename = "gg-step7-point.png", device = "png", 
        # width = 7, height = 5, units = "in")
```

Click on the `gg-step7-point.png` file in `ROOT` above to view the output. 

The `ggplot2::qplot()` function is smart enough to automatically choose a `geom` depending on what type of variable we assign to the `x` and `y` axes. In this case, the `percent_responding_right` variable is a `<dbl>` (numeric), and we've reformatted the `date` variable into a double before we passed it to the `y` axis.

The `ggplot2::qplot()` function knows to plot the dates on the `y` axes (notice it displays only the `year`) and represent the data with `geom = "points"`.

## step 8

- [x] included in the step8.md?

### Wrangling and visualization pipelines 

Sometimes we might want to pass the data directly from a wrangling step to a data visualization without assigning changes to the data frame. We will demonstrate how this works using the same `Brexit` dataset. 

If you read the [Medium article](https://medium.economist.com/mistakes-weve-drawn-a-few-8cdd8a42d368), you'll find The Economist first plotted these data as a line graph, with two lines (see 'Original' image below). The 'Better' way to improve the graph would be to include points and smooth the line in the graph (see below):

<!-- ![](https://github.com/mjfrigaard/katacoda-data-wrangle-viz-show/blob/master/figs/10-bremorse-plots-medium.png?raw=true) -->

```{r 10-bremorse-plots-medium-1, echo=FALSE}
# fs::dir_ls("../figs")
# https://raw.githubusercontent.com/mjfrigaard/katacoda-scenarios/master/figs/10-bremorse-plots-medium.png
# knitr::include_graphics(path = "../figs/10-bremorse-plots-medium.png")
knitr::include_graphics(path = "https://raw.githubusercontent.com/mjfrigaard/katacoda-scenarios/master/figs/10-bremorse-plots-medium.png")
```

In order to re-create these graphs, we'll need to restructure the `Brexit` data with the `tidyr::pivot_longer()` function we learned about in the last [scenario]().

Complete the code below by filling in the `cols = ` argument as `-date`, the `names_to = ` as `"poll"`, and the `values_to = ` as `"percent"`.

```
Brexit %>% pivot_longer(cols = , names_to =, values_to =)
```

We should end up with a dataset that has three variables: `date`, `poll`, and `percent`. The data below display the top six rows you should see when you've used `tidyr::pivot()` correctly. 

```
# A tibble: 170 x 3
   date       poll                     percent
   <date>     <chr>                      <dbl>
 1 2016-08-02 percent_responding_right      46
 2 2016-08-02 percent_responding_wrong      42
 3 2016-08-09 percent_responding_right      45
 4 2016-08-09 percent_responding_wrong      44
 5 2016-08-17 percent_responding_right      46
 6 2016-08-17 percent_responding_wrong      43
 7 2016-08-23 percent_responding_right      45
 8 2016-08-23 percent_responding_wrong      43
 9 2016-08-31 percent_responding_right      47
10 2016-08-31 percent_responding_wrong      44
# â€¦ with 160 more rows
```

#### Restructure and plot

After we're sure the data are structured correctly, we won't assign it to the `Brexit` data frame. Instead, we'll pass it straight through to the `ggplot2::qplot()` function. The `date` variable will go on the `x`, and the `percent` variable will go on the `y`. Click on the Run icon below to see the graph.

First, we will create the 'Original' graph by using `group = poll` and `geom = "line'`, because this allows us to build a separate colored line for each `poll`. 

```{r original-graph}
Brexit %>% 
  pivot_longer(cols = -date, 
               names_to = "poll", 
               values_to = "percent") %>% 
  ggplot2::qplot(x = date, 
                 y = percent,
                 group = poll,
                 data = .,
                 geom = "line",
                 color = poll)
# ggsave(filename = "gg-step8-line.png", device = "png", 
        # width = 7, height = 5, units = "in")
```

As we can see from the graph above, using `group` and the `color` aesthetic extends the `qplot()`'s capabilities by making it clear there are two categories for `polls` represented in the graph.

In the next step, we'll learn how to build a graph layer-by-layer!

## step 9

- [x] included in step9.md

### Build plots layer-by-layer with `ggplot()`

Now that we've learned how to plot using geoms and aesthetics, we can add layers to the graph. In the previous step, we re-created the 'Original' plot using `geom = "line"`. The `ggplot2::qplot()` function was written to "produce plots quickly", but more complex graphs should be built using the `ggplot2::ggplot()` function.

The `ggplot2::ggplot()` function initializes a graph, then we can 'map' variables to the positions (`x` or `y`), aesthetics (`color = `), or groupings (`group = `. 

We'll start by assigning the restructuring changes to the `Brexit` dataset. The `tidyr::pivot_longer()` function takes a 'wide' dataset and makes it 'long', or [tidy](https://vita.had.co.nz/papers/tidy-data.pdf).

```{r change-Brexit}
Brexit <- Brexit %>% pivot_longer(-date, 
                                  names_to = "poll", 
                                  values_to = "percent")
head(Brexit)
```

#### Using the `ggplot()` function

The `ggplot()` follows a pretty standard template, similar to the `qplot()` function. See below: 

```
<DATA> %>% 
  ggplot(mapping = aes(x = <MAPPINGS>, y = <MAPPINGS>))
```

We begin with a dataset, pass it over to to the `ggplot()` function, then map the `x` and `y` variables. 

Run the code below to assign the variable mappings to object `gg_p9`, then print `gg_p9` to the console. 

```{r gg-step9-p.png}
gg_p9 <- Brexit %>% ggplot(mapping = aes(x = date, y = percent))

# view gg_p9
gg_p9
# ggsave(filename = "gg-step9-p.png", device = "png", 
        # width = 7, height = 5, units = "in")
```

There aren't any points on the graph stored in object `gg_p9` because we haven't added any geoms or aesthetics. 

We'll add the smoothed line in the step below with `ggplot2::geom_smooth()` like the template below.

```
<DATA> %>% 
  ggplot(mapping = aes(x = <MAPPINGS>, y = <MAPPINGS>)) + 
    <GEOM_FUNCTION>(mapping = aes(<MAPPINGS>))
```

**Note**: the `+` operator is used with `ggplot2` functions, not the pipe `%>%` operator.  

```{r geom_smooth}
gg_p9 + ggplot2::geom_smooth()
# ggsave(filename = "gg-step9-smooth.png", device = "png", 
        # width = 7, height = 5, units = "in")
```

*Why are we only seeing a single line?* We need to look at our template again:

```
<DATA> %>% 
  ggplot(mapping = aes(x = <MAPPINGS>, y = <MAPPINGS>)) + 
    <GEOM_FUNCTION>(mapping = aes(<MAPPINGS>))
```

We can see from the template above that we can set the aesthetic mappings (`aes(<MAPPINGS>)`) globally *and* inside the geom layer we want to display. 

In this case, we want the lines from `geom_smooth()` colored by the two kinds of polls. We can set this with `color = poll`.

```{r aes-color}
gg_p9 + 
  ggplot2::geom_smooth(aes(color = poll))

# ggsave(filename = "gg-step9-color.png", device = "png", 
        # width = 7, height = 5, units = "in")

# view gg-step9-smooth.png
```

The default `ggplot2::geom_smooth()` function includes the gray confidence interval around the smoothed line. We can remove this with `se = FALSE`. We'll also add the `show.legend = FALSE` argument to remove the `poll` categories from the left-hand side of the graph.

Run the code below to assign the graph to the `gg_p9_col_smth` object.

```{r gg_p9_col_smth}
gg_p9_col_smth <- gg_p9 + geom_smooth(aes(color = poll), 
                                   se = FALSE, show.legend = FALSE)
gg_p9_col_smth
# ggsave(filename = "gg-step9-col-smth.png", device = "png", 
#        width = 7, height = 5, units = "in")
# view gg-step9-smooth-2.png
```

In the next step, we'll add the points to the graph. We've also updated the template below for adding aesthetics.

```
<DATA> %>% 
  ggplot(mapping = aes(x = <MAPPINGS>, y = <MAPPINGS>)) + 
    <GEOM_FUNCTION>(mapping = aes(<MAPPINGS>), 
                    optional_arguments = "values")
```

## step 10

- [x] included in step10.md

### Adding aesthetics and layers 

In the last step we added a `geom_smooth()` to the `gg_p9_col_smth` object and removed the standard errors (`se = FALSE`) and legend (`show.legend = FALSE`). We stored these changes in the `gg-step9-col-smth.png` file. Refer to the template below for a refresher.

```
<DATA> %>% 
  ggplot(mapping = aes(x = <MAPPINGS>, y = <MAPPINGS>)) + 
    <GEOM_FUNCTION>(mapping = aes(<MAPPINGS>), 
                    optional_arguments = "values")
```

We're going to continue building our plot by adding the `ggplot2::geom_point()` function. We need to specify the `aes()` argument (`color = poll`), and we'll also include the `show.legend = FALSE` argument again to remove the legend for the two `poll` categories.

Click on the section below to add points to the smooth plot:

```{r geom_point}
gg_p9_col_smth + geom_point(aes(color = poll), show.legend = FALSE)
# ggsave(filename = "gg-step9-col-smth.png", device = "png", 
       # width = 7, height = 5, units = "in")
```

This is starting to look more like the graph in the medium article, but we still need to make a few minor adjustments. 

<!-- ![](https://github.com/mjfrigaard/katacoda-data-wrangle-viz-show/blob/master/figs/10-bremorse-plots-medium.png?raw=true) -->

```{r 10-bremorse-plots-medium-2, echo=FALSE}
# fs::dir_ls("../figs")
# knitr::include_graphics(path = "../figs/10-bremorse-plots-medium.png")
knitr::include_graphics(path = "https://raw.githubusercontent.com/mjfrigaard/katacoda-scenarios/master/figs/10-bremorse-plots-medium.png")
```

`ggplot2` allows us to build graphs layer-by-layer using the geoms and aesthetics to customize each plot so that they are necessarily expressive. Each time we need to add something to a graph, we can either add a new `geom`, or look for ways to adjust a geoms with new aesthetic options. 

For example, from the 'Original' graph in the medium article, the points are slightly transparent. The `alpha` is the transparency argument, and it's available inside nearly every `geom`. 

We can add the `alpha` argument inside the `ggplot2::geom_point()` function, and specify either a decimal, fraction, or numeric value. In this case, we want the value set to `1/3`.

Click below to change the `alpha` level.

```{r gg_p10_alpha}
gg_p10_alpha <- gg_p9_col_smth + 
  geom_point(aes(color = poll), show.legend = FALSE, alpha = 1/3)
gg_p10_alpha
# ggsave(filename = "gg-step10-alpha.png", device = "png",
       # width = 7, height = 5, units = "in")
```

View `gg-step10-alpha.png` in the vscode IDE. Now the points are slightly transparent, which helps with over-plotting. Review the template below for adding layers. 

```
<DATA> %>% 
  ggplot(mapping = aes(x = <MAPPINGS>, y = <MAPPINGS>)) + 
    <GEOM_FUNCTION>(mapping = aes(<MAPPINGS>), args = "options")
```

As you can see, the grammar of graphics makes it easy to think about what we'd like to see on a plot, decide what kind of graph element it is (`geom`, `aesthetic`, etc.), and then add it as a layer with the `+` operator. Hopefully, you can see how easy it is to customize a graph by adding new layers and aesthetics!

## step 11

- [x] included in step11.md?

### Mapping aesthetics globally

**Note**: so far, we have added the `aes()` arguments *locally* in each new `geom` layer we've built. This section will map these variables *globally* in the `ggplot()` function. See the code below:

```{r mapp-in-ggplot}
gg_p11 <- Brexit %>% 
  ggplot(mapping = aes(x = date, y = percent, color = poll)) + 
              geom_smooth(se = FALSE, show.legend = FALSE) + 
                geom_point(alpha = 1/3, show.legend = FALSE)
gg_p11
# save
# ggsave(filename = "gg-step11-global.png", device = "png", 
       # width = 7, height = 5, units = "in")
```

By adding `color = poll` in the `ggplot()` function, the aesthetic carries down through each `geom`. All we have to do is add the arguments for each `geom`. 

#### Adding colors manually

We want to change the graph's colors from the default settings to fire-brick red and cornflower blue. We can do this by adding the `ggplot2::scale_color_manual()` function and specifying the values(`c("cornflowerblue", "firebrick3")`).

Fill in the code below and save the new changes to the `gg_p11_scale` object. 

```{r scale_color_manual}
gg_p11_scale <- gg_p11 +  
  scale_color_manual(values = c("cornflowerblue", "firebrick3"))
gg_p11_scale

# save
# ggsave(filename = "gg-step11-scale.png", device = "png", 
       # width = 7, height = 5, units = "in")
```

View the `gg-step11-scale.png` file in the vscode IDE. 

For a full list of colors, check the pdf [here](http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf).

## step12

- [x] included in step12.md

### Adding text to a graph 

In the [Medium article](https://medium.economist.com/mistakes-weve-drawn-a-few-8cdd8a42d368), the fixed 'Better' graph labels each smoothed line with `'Wrong'` vs `'Right'`. 

We're going to add text labels to our graph using the `ggplot2::geom_text()` function. The `gg_p11_scale` object has the latest changes to the plot.

#### Using the `geom_text()` function

`ggplot2::geom_text()` works on a Cartesian coordinate system and requires the `x`, `y`, and `label` arguments. We want to place the `Wrong` label at the intersection of percent `46`, just above the red line near the year `2018`.

Recall that the dates are formatted as `YYYY-MM-DD`, so we have to pick an `x` value that we can specify as a date with `as.Date()`. See the example below:

```
gg_p11_scale + 
  geom_text(label = "Wrong", color = "firebrick3", 
            x = as.Date("2018-01-01"), y = 46)
```

Now we want to add the `Right` label to the graph, but make this cornflower blue, at position `x` = `as.Date("2018-01-01")` and `y` = `42.5`. Click the section below to add the text to the graph:

```{r gg_p12_txt}
gg_p12_txt <- gg_p11_scale + 
  geom_text(label = "Wrong", color = "firebrick3", 
            x = as.Date("2018-01-01"), y = 46) + 
  geom_text(label = "Right", color = "cornflowerblue", 
            x = as.Date("2018-01-01"), y = 42.5)
gg_p12_txt

# save
# ggsave(filename = "gg-step12-txt.png", device = "png", 
       # width = 7, height = 5, units = "in")
```

These labels match up with the Medium article graph below: 

<!-- ![](https://github.com/mjfrigaard/katacoda-data-wrangle-viz-show/blob/master/figs/12-bremore-better.png?raw=true) -->

```{r 12-bremorse-better, echo=FALSE}
# fs::dir_ls("../figs")
# knitr::include_graphics(path = "../figs/12-bremore-better.png")
knitr::include_graphics(path = "https://raw.githubusercontent.com/mjfrigaard/katacoda-scenarios/master/figs/12-bremore-better.png")
```

In the next step, we will move the `y` axis over to the right-hand side of the graph.

## step13

- [x] included in step13.md

### Adjusting axes on a graph

Our graph is coming along, but we should shift the `y` axes to the opposite side of the graph (like the image below). 

<!-- ![](https://github.com/mjfrigaard/katacoda-data-wrangle-viz-show/blob/master/figs/12-bremore-better.png?raw=true) -->

```{r 12-bremorse-better-2, echo=FALSE}
# fs::dir_ls("../figs")
# knitr::include_graphics(path = "../figs/12-bremore-better.png")
knitr::include_graphics(path = "https://raw.githubusercontent.com/mjfrigaard/katacoda-scenarios/master/figs/12-bremore-better.png")
```

#### Moving the `y` axis

`ggplot2` has a rich grammar for building graphs, which means it has a function for doing nearly anything we can think of, including moving axes. To shift the `y` axis from it's original position, we can use the `ggplot2::scale_y_continuous()` function and specify `"right"` in the `position =` argument.

Run the code below and assign these changes to `gg_p13_y` and print it to the screen.

```{r scale_y_continuous}
gg_p13_y <- gg_p12_txt + 
  ggplot2::scale_y_continuous(position = "right")
gg_p13_y

# ggsave(filename = "gg-step13-y-axis.png", device = "png", 
       # width = 7, height = 5, units = "in")
```

View the `gg-step13-y-axis.png` file and compare it to the `Better' graph. 

Now we have the lines, the points, the plot labels, and the axes in the correct spot. Next up, we need to make sure our chart is titled and labeled correctly!

## step14 

- [x] included in step14.md

### Adding labels 

Titles and labels are important because they give readers the context of the information they see in a graph. Without some additional information about the data, the audience is just staring at lines, points, colors, etc.

`ggplot2` has a few options for labeling graphs, but we recommend using the standard `ggplot2::labs()` function. It's easy to remember, and it has most of the necessary arguments you'll need for almost all the graphs you'll build. 

#### Using the `ggplot2::labs()` function

Below is a set of arguments that match the title and labels from the 'Better' graph from the Medium article. 

<!-- ![](https://github.com/mjfrigaard/katacoda-data-wrangle-viz-show/blob/master/figs/12-bremore-better.png?raw=true) -->

```{r 12-bremorse-better-4, echo=FALSE}
# fs::dir_ls("../figs")
# knitr::include_graphics(path = "../figs/12-bremore-better.png")
knitr::include_graphics(path = "https://raw.githubusercontent.com/mjfrigaard/katacoda-scenarios/master/figs/12-bremore-better.png")

```

As you can see, the Economist article chose to remove the `x` and `y` axes labels, but we think it's clearer to leave them in. Run the code below to create the `labs_eco` layer.

```{r labs_eco}
labs_eco <- ggplot2::labs(title = "Bremorse", 
                subtitle = "'In hindsight, do you think Britain was right or wrong to vote to leave the EU?'", 
                caption = "Source: NatCen Social Research", 
                x = "Date", 
                y = "Percent (%)")
```

We store the labels in the `labs_eco` object, which we can add to the `gg_p13_y` object and reassign this to the `gg_p14_labs` object. 

Run the code below to assign the labels layer to the plot object. 

```{r gg_p14_labs}
gg_p14_labs <- gg_p13_y + labs_eco
gg_p14_labs
```

Labels are also important for keeping track of your work. If you're exploring a dataset using graphs (a process called [Exploratory Data Analysis](https://en.wikipedia.org/wiki/Exploratory_data_analysis), or EDA), the labels can help you remember what transformations or changes you made to the data under hood.   


## step15

- [x] included in step15.md

### Using themes

Our graph is nearly complete! We have all the geoms, aesthetics, titles, and labels. The last thing we will add is a theme, but we will do this by going outside the `tidyverse` to the [`ggthemes`](https://yutannihilation.github.io/allYourFigureAreBelongToUs/ggthemes/) package. 

#### `ggthemes` 

The `ggthemes` package has pre-packaged design, color, and font choices for most popular media outlets (FiveThirtyEight, Wall Street Journal, etc.). We'll use the `ggthemes::theme_economist_white()` function to change our plot's colors and design.

Install this package by clicking on the code section below:

```r
install.packages("ggthemes")
library(ggthemes)
```

This function takes a `gray_bg = ` argument, which we will set to `FALSE`. We'll also change the `base_size` for the font to `12`, and the default font family to `"Verdana"`.

```{r theme_economist_white}
gg_p14_labs + ggthemes::theme_economist_white(gray_bg = FALSE, 
                                     base_size = 12, 
                                     base_family = "Verdana")

# ggsave(filename = "gg-step15-ggthemes.png", device = "png", 
       # width = 7, height = 5, units = "in")
```

This looks pretty close, right? Compare to the image below:

<!-- ![](https://github.com/mjfrigaard/katacoda-data-wrangle-viz-show/blob/master/figs/12-bremore-better.png?raw=true) -->

```{r 12-bremorse-better-5, echo=FALSE}
# fs::dir_ls("../figs")
# knitr::include_graphics(path = "../figs/12-bremore-better.png")
knitr::include_graphics(path = "https://raw.githubusercontent.com/mjfrigaard/katacoda-scenarios/master/figs/12-bremore-better.png")
```

## finish

- [x] included in finish.md?

This wraps up our scenario, "*Build beautiful, customized graphs and charts in R with `ggplot2`*". 

We hope you feel more comfortable creating graphs with `ggplot2`, and that you have plenty of code to adapt to your needs. Please check out the other scenarios on R and the `tidyverse`!

## Appendix 1: Katacoda scenario tutorials

The tutorial for building the scenario is [here](https://katacoda.com/scenario-examples/scenarios/create-scenario-101).

I took notes on this tutorial and made them available in [this Google document](https://docs.google.com/document/d/e/2PACX-1vSf2w2onhH5t3IhuD4sYLoWqn46BLKMYFR7q3BHO8QTaRkVgXfhKvnl8T9uHrjmbVpTZVKCWrfxEl0R/pub).

## Appendix 2: Katacoda guidelines

There are multiple guidelines and resources for writing scenarios. O'Reilly has provided an *Authoring Guide* and *Formatting and Design Guide*.

The link for these files can be found here:

+ [Katacoda Scenario Formatting and Design Guide for Authors](https://docs.google.com/document/d/1l4lofG5kAu8JFzumZPCsJJE2muCYe6rHSHCQsMlijd8/edit)

+ [Katacoda Scenario Authoring Guide](https://docs.google.com/document/d/14rudtruZQhRxvD3zcR3g75j5nuOgKGz4CYk8hdhaV-w/edit)

## Appendix 3: Scenario Checklist

**Scenario Readiness Checklist:**

When you think your scenario is ready for publication, we recommend you run through the checklist below to ensure it is ready to go. [Reminder: We discuss these best practices in the Katacoda Formatting and Design Guide for Authors]:

Does the scenario start consistently and in a timely manner? More than 5 minutes to start would be cause to reconsider your build decisions.

- [x] Are your intro and final pages present and are their respective goals and lessons learned in agreement?

- [ ] Have you tested your scenario lately?

- [x] Do you agree with the leveling (beginner, intermediate, advanced) you indicated when you started the build?

- [x] Was learning time you entered correct, or should it be adjusted?

- [ ] Are your versions of tools and other dependencies up to date?

- [ ] Have you tried every instruction?

- [ ] Have you written each step in the most concise manner possible?

- [ ] Have you run your text through a spelling/grammar checker?

- [ ] Are your credits to others given present and correct?

- [ ] Are your images legal and with credits?

- [ ] Are your hyperlinks all working?

- [ ] Do the goals and lessons learned items match the steps in the scenario?

